## Задача

Распараллелить загрузку X картинок на сервер, чтобы в каждый момент времени загружалось не
более N картинок?

- Одна реализация - coroutine  
- Вторая реализация - multithreading

## Решение
- Для асинхронной реализации в качестве клиента использовал `aiohttp` c `TaskGroup` и `Semaphore` для 
ограничения количества одновременных запросов.
- Для многопоточной реализации использовал `threading.Thread`. Спавнятся `MAX_CONCURRENT_UPLOADS` потоков, 
задания на загрузку они получают из очереди, результат они отдают в залоченный с `threading.Lock()` список.

### Структура проекта

```
.
├── app                 
│   ├── clients         # Модуль с клиентами
│   │   ├── __init__.py
│   │   ├── _base.py          # Базовый абстрактный класс для клиентов
│   │   ├── async_client.py   # Асинхронный клиент
│   │   └── thread_client.py  # Клиент, использующий многопоточность
|   ├── config.py       # Конфигурация сервера (хост, порт), лимит загрузок
│   ├── server.py       # aiohttp mock-сервер, симулирующий обработку запросов
│   └── utils.py        # Вспомогательные функции
├── tests
│   ├── __init__.py
│   ├── test_async.py     # Тесты для асинхронного клиента
│   └── test_threads.py    # Тесты для клиента с многопоточностью
├── README.md
├── requirements.txt
├── .gitignore
└── pytest.ini
```

## Запуск

python 3.11

    ```bash
    pip install -r requirements.txt
    ```

## Тесты

```bash
pytest -s 
```

Тесты проверяют, что в каждый момент времени загружается не более `MAX_CONCURRENT_UPLOADS` (в `config.py`) картинок.  
При превышении порога сервер возвращает **429** ошибку.  
При получении **429** ошибки клиент должен повторить запрос. Максимальное количество попыток - 3.  
Также с вероятностью 10% сервер может вернуть **500** ошибку. В этом случае клиент также будет повторять запрос.

#### Примечания

- Логгирование принтами, в реальном проекте использовал бы логгер.
- Лимит загрузок в глобальной переменной, в реальном проекте использовал бы redis/memcached.